<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiger & Hunters</title>
    <style>
        body { margin: 0; padding: 20px; background: #2c3e50; font-family: sans-serif; }
        #game-container { display: flex; gap: 20px; background: white; padding: 20px; border-radius: 10px; }
        canvas { border: 2px solid #34495e; cursor: grab; }
        canvas:active { cursor: grabbing; }
        #ui { width: 280px; }
        #status { background: #ecf0f1; padding: 10px; border-radius: 5px; margin: 10px 0; min-height: 60px; font-size: 14px; }
        .error { color: #e74c3c; font-weight: bold; }
        .success { color: #27ae60; font-weight: bold; }
        #turn-indicator { color: #e74c3c; margin: 0 0 10px 0; font-size: 24px; }
        #reset-btn, #undo-btn { width: 100%; padding: 10px; margin: 5px 0; border: none; border-radius: 5px; cursor: pointer; }
        #reset-btn { background: #3498db; color: white; }
        #undo-btn { background: #e67e22; color: white; display: none; }
        #undo-btn:hover { background: #d35400; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="800"></canvas>
        <div id="ui">
            <h1 id="turn-indicator">Loading...</h1>
            <div id="status">Initializing drag controls...</div>
            <button id="reset-btn">New Game</button>
            <button id="undo-btn">Undo Current Move</button>
            <div id="rules">
                <h3>How to Play</h3>
                <p><strong>1. Click & HOLD</strong> a piece</p>
                <p><strong>2. DRAG</strong> it (yellow circle = range)</p>
                <p><strong>3. RELEASE</strong> to place it</p>
                <p><strong>Undo:</strong> Click button to undo your *current* move</p>
            </div>
        </div>
    </div>

    <script>
        // ========== STATUS LOGGER ==========
        function logStatus(message, type = "info") {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<span class="${type}">${message}</span>`;
            console.log(message);
        }

        // ========== CORE CLASSES ==========
        class Vector2 {
            constructor(x, y) { this.x = x; this.y = y; }
            distanceTo(other) { return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2); }
            clone() { return new Vector2(this.x, this.y); }
        }

        class Piece {
            constructor(pos, color, isTiger = false) {
                this.pos = pos;
                this.originalPos = pos.clone(); // For undo
                this.color = color;
                this.isTiger = isTiger;
                this.incapacitated = false;
                this.hasMoved = false;
                this.radius = 15;
                this.isSelected = false;
            }
            
            draw(ctx) {
                // Draw selection ring
                if (this.isSelected) {
                    ctx.strokeStyle = '#f1c40f';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Alpha for moved pieces
                ctx.save();
                if (this.incapacitated) {
                    ctx.fillStyle = '#7f8c8d';
                } else if (this.hasMoved) {
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = 0.4;
                } else {
                    ctx.fillStyle = this.color;
                }
                
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Incapacitated X
                if (this.incapacitated) {
                    ctx.strokeStyle = '#c0392b';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x - 10, this.pos.y - 10);
                    ctx.lineTo(this.pos.x + 10, this.pos.y + 10);
                    ctx.moveTo(this.pos.x - 10, this.pos.y + 10);
                    ctx.lineTo(this.pos.x + 10, this.pos.y - 10);
                    ctx.stroke();
                }
            }

            contains(point) {
                return this.pos.distanceTo(point) <= this.radius + 5; // Larger grab zone
            }
        }

        // ========== GAME CONSTANTS ==========
        const HAND_SPAN = 150;
        const CLEARING_RADIUS = 300;
        const BORDERLANDS_WIDTH = HAND_SPAN;

        // ========== GAME LOGIC ==========
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.center = new Vector2(400, 400);
                this.dragState = { // NEW: Track dragging
                    piece: null,
                    offset: null,
                    currentPos: null,
                    isDragging: false
                };
                this.undoBuffer = []; // NEW: Store move for undo
                this.reset();
                this.setupEventListeners();
            }

            reset() {
                this.tiger = new Piece(this.center.clone(), '#e74c3c', true);
                this.hunters = [];
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 72) * Math.PI / 180;
                    const dist = CLEARING_RADIUS + 75;
                    const pos = new Vector2(
                        this.center.x + Math.cos(angle) * dist,
                        this.center.y + Math.sin(angle) * dist
                    );
                    this.hunters.push(new Piece(pos, '#27ae60'));
                }
                
                this.turn = 'TIGER';
                this.huntersMoved = new Set();
                this.winner = null;
                this.undoBuffer = [];
                this.dragState = { piece: null, offset: null, currentPos: null, isDragging: false };
                
                document.getElementById('undo-btn').style.display = 'none';
                logStatus("Game ready! Click & DRAG the Tiger to move.");
                this.draw();
            }

            setupEventListeners() {
                // MOUSE DOWN - Start drag
                this.canvas.addEventListener('mousedown', (e) => {
                    if (this.winner) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const mousePos = new Vector2(e.clientX - rect.left, e.clientY - rect.top);
                    const piece = this.getPieceAt(mousePos);
                    
                    if (piece) {
                        if (this.turn === 'TIGER' && !piece.isTiger) {
                            logStatus("It's Tiger's turn!", "error");
                            return;
                        }
                        if (this.turn === 'HUNTERS' && piece.isTiger) {
                            logStatus("It's Hunters' turn!", "error");
                            return;
                        }
                        if (this.turn === 'HUNTERS' && this.huntersMoved.has(piece)) {
                            logStatus("That Hunter already moved!", "error");
                            return;
                        }
                        
                        this.startDrag(piece, mousePos);
                    }
                });

                // MOUSE MOVE - Dragging
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!this.dragState.isDragging) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const mousePos = new Vector2(e.clientX - rect.left, e.clientY - rect.top);
                    
                    this.dragState.currentPos = mousePos;
                    this.dragState.piece.pos = new Vector2(
                        mousePos.x - this.dragState.offset.x,
                        mousePos.y - this.dragState.offset.y
                    );
                    
                    this.draw();
                });

                // MOUSE UP - End drag / place piece
                this.canvas.addEventListener('mouseup', (e) => {
                    if (!this.dragState.isDragging) return;
                    
                    const piece = this.dragState.piece;
                    const targetPos = piece.pos.clone(); // Where the piece was dragged to
                    
                    this.endDrag();
                    
                    // Validate placement
                    const dist = piece.originalPos.distanceTo(targetPos);
                    if (dist > HAND_SPAN) {
                        logStatus(`Too far! Max distance: ${HAND_SPAN}px`, "error");
                        this.cancelDrag(); // Snap back
                        return;
                    }
                    
                    // Zone validation
                    if (piece.isTiger && targetPos.distanceTo(this.center) > CLEARING_RADIUS) {
                        logStatus("Tiger cannot leave Clearing!", "error");
                        this.cancelDrag();
                        return;
                    }
                    
                    const maxDist = this.center.distanceTo(targetPos);
                    if (maxDist > CLEARING_RADIUS + BORDERLANDS_WIDTH) {
                        logStatus("Cannot leave the play area!", "error");
                        this.cancelDrag();
                        return;
                    }
                    
                    // Valid move - save to undo buffer
                    this.undoBuffer.push({
                        piece: piece,
                        from: piece.originalPos,
                        to: targetPos.clone()
                    });
                    
                    // Execute move
                    if (piece.isTiger) {
                        this.executeTigerMove(targetPos);
                    } else {
                        this.executeHunterMove(piece, targetPos);
                    }
                });

                // Prevent accidental drags off-canvas
                this.canvas.addEventListener('mouseleave', () => {
                    if (this.dragState.isDragging) this.cancelDrag();
                });

                // Undo button
                document.getElementById('undo-btn').addEventListener('click', () => {
                    this.undoMove();
                });
            }

            startDrag(piece, mousePos) {
                piece.isSelected = true;
                piece.originalPos = piece.pos.clone();
                
                this.dragState = {
                    piece: piece,
                    offset: new Vector2(
                        mousePos.x - piece.pos.x,
                        mousePos.y - piece.pos.y
                    ),
                    currentPos: mousePos,
                    isDragging: true
                };
                
                this.canvas.style.cursor = 'grabbing';
                logStatus(`Dragging ${piece

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiger & Hunters</title>
    <style>
        body { margin: 0; padding: 20px; background: #2c3e50; font-family: sans-serif; }
        #game-container { display: flex; gap: 20px; background: white; padding: 20px; border-radius: 10px; }
        canvas { border: 2px solid #34495e; cursor: pointer; }
        #ui { width: 280px; }
        #status { background: #ecf0f1; padding: 10px; border-radius: 5px; margin: 10px 0; min-height: 60px; font-size: 14px; }
        .error { color: #e74c3c; font-weight: bold; }
        .success { color: #27ae60; font-weight: bold; }
        #turn-indicator { color: #e74c3c; margin: 0 0 10px 0; font-size: 24px; }
        #reset-btn { width: 100%; padding: 10px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="800"></canvas>
        <div id="ui">
            <h1 id="turn-indicator">Loading...</h1>
            <div id="status">Initializing...</div>
            <button id="reset-btn">New Game</button>
            <div id="rules">
                <h3>How to Play</h3>
                <p><strong>1. Click a piece</strong> â†’ Yellow ring appears</p>
                <p><strong>2. Click inside the ring</strong> to move there</p>
                <p><strong>3. Click outside the ring</strong> to cancel</p>
            </div>
        </div>
    </div>

    <script>
        // ========== STATUS LOGGER ==========
        function logStatus(message, type = "info") {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<span class="${type}">${message}</span>`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // ========== VECTOR & PIECE ==========
        class Vector2 {
            constructor(x, y) { this.x = x; this.y = y; }
            distanceTo(other) { return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2); }
            clone() { return new Vector2(this.x, this.y); }
        }

        class Piece {
            constructor(pos, color, isTiger = false) {
                this.pos = pos;
                this.color = color;
                this.isTiger = isTiger;
                this.incapacitated = false;
                this.hasMoved = false;
                this.radius = 15;
                this.isSelected = false;
                this.isVictoryPiece = false;
            }
            
            draw(ctx) {
                if (this.isVictoryPiece) {
                    ctx.strokeStyle = '#2ecc71';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 10, 0, Math.PI * 2);
                    ctx.stroke();
                }

                if (this.isSelected) {
                    ctx.strokeStyle = '#f1c40f';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.save();
                if (this.incapacitated) {
                    ctx.fillStyle = '#7f8c8d';
                } else if (this.hasMoved) {
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = 0.4;
                } else {
                    ctx.fillStyle = this.color;
                }
                
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                if (this.incapacitated) {
                    ctx.strokeStyle = '#c0392b';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x - 10, this.pos.y - 10);
                    ctx.lineTo(this.pos.x + 10, this.pos.y + 10);
                    ctx.moveTo(this.pos.x - 10, this.pos.y + 10);
                    ctx.lineTo(this.pos.x + 10, this.pos.y - 10);
                    ctx.stroke();
                }
            }

            contains(point) {
                return this.pos.distanceTo(point) <= this.radius + 5;
            }
        }

        // ========== GAME CONSTANTS ==========
        const HAND_SPAN = 150;
        const CLEARING_RADIUS = 300;
        const BORDERLANDS_WIDTH = HAND_SPAN;

        // ========== MAIN GAME ==========
        class Game {
            constructor() {
                console.log("=== GAME INITIALIZING ===");
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.center = new Vector2(400, 400);
                this.selectedPiece = null;
                this.winningHunters = null;
                this.reset();
                this.setupEventListeners();
                console.log("=== GAME READY ===");
            }

            reset() {
                console.log("--- RESETING GAME ---");
                this.tiger = new Piece(this.center.clone(), '#e74c3c', true);
                this.hunters = [];
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 72) * Math.PI / 180;
                    const dist = CLEARING_RADIUS + 75;
                    const pos = new Vector2(
                        this.center.x + Math.cos(angle) * dist,
                        this.center.y + Math.sin(angle) * dist
                    );
                    this.hunters.push(new Piece(pos, '#27ae60'));
                }
                
                this.turn = 'TIGER';
                this.huntersMoved = new Set();
                this.winner = null;
                this.winningHunters = null;
                this.selectedPiece = null;
                
                logStatus("Game ready! Click the TIGER (red piece) to select it.");
                this.draw();
            }

            setupEventListeners() {
                console.log("Setting up click listener...");
                this.canvas.addEventListener('click', (e) => {
                    if (this.winner) {
                        logStatus("Game over! Click New Game to play again.");
                        return;
                    }
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const clickPos = new Vector2(e.clientX - rect.left, e.clientY - rect.top);
                    
                    console.log(`Click at (${clickPos.x}, ${clickPos.y})`);
                    
                    if (!this.selectedPiece) {
                        // No piece selected - try to select one
                        console.log("No piece selected. Searching...");
                        const piece = this.getPieceAt(clickPos);
                        if (piece) {
                            console.log(`Found piece: ${piece.isTiger ? 'Tiger' : 'Hunter'}`);
                            this.selectPiece(piece);
                        } else {
                            console.log("No piece at click location");
                            logStatus("Click a piece to select it.", "error");
                        }
                    } else {
                        // Piece selected - try to move it
                        console.log(`Selected piece exists: ${this.selectedPiece.isTiger ? 'Tiger' : 'Hunter'}`);
                        this.handlePlacementClick(clickPos);
                    }
                });
                
                console.log("Click listener attached successfully.");
            }

            getPieceAt(pos) {
                console.log(`Checking for piece at (${pos.x}, ${pos.y})`);
                if (this.tiger.contains(pos)) {
                    console.log("Found TIGER");
                    return this.tiger;
                }
                for (let i = 0; i < this.hunters.length; i++) {
                    const h = this.hunters[i];
                    if (!h.incapacitated && h.contains(pos)) {
                        console.log(`Found HUNTER #${i}`);
                        return h;
                    }
                }
                console.log("No piece found at click location");
                return null;
            }

            selectPiece(piece) {
                console.log(`Selecting piece: ${piece.isTiger ? 'Tiger' : 'Hunter'}`);
                
                // Validate turn
                if (this.turn === 'TIGER' && !piece.isTiger) {
                    logStatus("Tiger's turn! Select the red piece.", "error");
                    return;
                }
                if (this.turn === 'HUNTERS' && piece.isTiger) {
                    logStatus("Hunters' turn! Select a green piece.", "error");
                    return;
                }
                if (this.turn === 'HUNTERS' && this.huntersMoved.has(piece)) {
                    logStatus("That Hunter already moved! Pick another.", "error");
                    return;
                }

                // Deselect old, select new
                if (this.selectedPiece) this.selectedPiece.isSelected = false;
                this.selectedPiece = piece;
                piece.isSelected = true;

                const name = piece.isTiger ? 'Tiger' : 'Hunter';
                const movesLeft = this.turn === 'HUNTERS' ? `(${5 - this.huntersMoved.size} remaining)` : '';
                logStatus(`${name} selected ${movesLeft}. Now click INSIDE the yellow ring to move.`, "success");
                this.draw();
            }

            handlePlacementClick(clickPos) {
                console.log(`Placement click at (${clickPos.x}, ${clickPos.y})`);
                
                const origin = this.selectedPiece.originalPos || this.selectedPiece.pos;
                const dist = origin.distanceTo(clickPos);
                
                console.log(`Distance from origin: ${dist} (max: ${HAND_SPAN})`);
                
                // Check if click is OUTSIDE range (cancel)
                if (dist > HAND_SPAN) {
                    console.log("Click outside range - CANCELLING selection");
                    this.selectedPiece.isSelected = false;
                    this.selectedPiece = null;
                    logStatus("Move cancelled. Click a piece to select.", "error");
                    this.draw();
                    return;
                }
                
                // Valid placement within range
                console.log("Valid placement! Executing move...");
                const targetPos = clickPos.clone();
                
                // Zone validation
                if (this.selectedPiece.isTiger && targetPos.distanceTo(this.center) > CLEARING_RADIUS) {
                    logStatus("Tiger cannot leave the Clearing!", "error");
                    return;
                }
                
                const maxDist = targetPos.distanceTo(this.center);
                if (maxDist > CLEARING_RADIUS + BORDERLANDS_WIDTH) {
                    logStatus("Cannot leave the play area!", "error");
                    return;
                }
                
                // Execute move
                if (this.selectedPiece.isTiger) {
                    this.executeTigerMove(targetPos);
                } else {
                    this.executeHunterMove(this.selectedPiece, targetPos);
                }
            }

            executeTigerMove(targetPos) {
                console.log("Executing Tiger move...");
                this.tiger.pos = targetPos.clone();
                
                const landedHunter = this.hunters.find(h => 
                    !h.incapacitated && h.pos.distanceTo(targetPos) < 10
                );

                if (landedHunter) {
                    logStatus("Tiger landed on a Hunter! Chain pouncing...");
                    this.executePounceChain();
                } else {
                    const threatened = this.hunters.filter(h => 
                        !h.incapacitated && h.pos.distanceTo(targetPos) <= HAND_SPAN
                    ).length;
                    if (threatened > 0) logStatus(`ROAR! ${threatened} Hunter(s) threatened!`);
                    this.endTigerTurn();
                }
            }

            executePounceChain() {
                console.log("Starting pounce chain...");
                let currentPos = this.tiger.pos;
                let chainCount = 0;

                while (true) {
                    const targets = this.hunters
                        .filter(h => !h.incapacitated && h.pos.distanceTo(currentPos) <= HAND_SPAN)
                        .sort((a, b) => a.pos.distanceTo(currentPos) - b.pos.distanceTo(currentPos));

                    if (!targets.length) {
                        console.log("No more targets in range, chain ended");
                        break;
                    }

                    const target = targets[0];
                    console.log(`Pouncing Hunter at (${target.pos.x}, ${target.pos.y})`);
                    target.incapacitated = true;
                    chainCount++;
                    currentPos = target.pos;
                    logStatus(`Chain pounce #${chainCount}!`);

                    if (this.hunters.every(h => h.incapacitated)) {
                        console.log("All hunters incapacitated - TIGER WINS");
                        this.winner = 'TIGER';
                        this.endGame();
                        return;
                    }
                }

                this.endTigerTurn();
            }

            endTigerTurn() {
                console.log("Ending Tiger turn...");
                if (this.selectedPiece) this.selectedPiece.isSelected = false;
                this.selectedPiece = null;
                
                this.hunters.forEach(h => h.hasMoved = false);
                this.turn = 'HUNTERS';
                this.huntersMoved.clear();
                
                logStatus("Hunters' turn - all refreshed (full color).");
                this.draw();
            }

            executeHunterMove(hunter, targetPos) {
                console.log("Executing Hunter move...");
                hunter.pos = targetPos.clone();
                hunter.hasMoved = true;
                this.huntersMoved.add(hunter);
                logStatus("Hunter moved (now darker).");

                const rescued = this.hunters.find(h => 
                    h !== hunter && h.incapacitated && h.pos.distanceTo(targetPos) < 10
                );

                if (rescued) {
                    rescued.incapacitated = false;
                    logStatus("Hunter rescued!", "success");
                }

                this.selectedPiece.isSelected = false;
                this.selectedPiece = null;

                this.checkVictory();
            }

            checkVictory() {
                console.log("Checking victory conditions...");
                
                // Tiger win
                if (this.hunters.every(h => h.incapacitated)) {
                    console.log("TIGER VICTORY");
                    this.winner = 'TIGER';
                    this.endGame();
                    return;
                }

                // Hunter win
                const activeInClearing = this.hunters.filter(h => 
                    !h.incapacitated && h.pos.distanceTo(this.center) <= CLEARING_RADIUS
                );

                if (activeInClearing.length >= 3) {
                    const nearTiger = activeInClearing.filter(h => h.pos.distanceTo(this.tiger.pos) <= 200);
                    if (nearTiger.length >= 3) {
                        console.log("HUNTER VICTORY");
                        this.winner = 'HUNTERS';
                        this.winningHunters = nearTiger.slice(0, 3);
                        this.winningHunters.forEach(h => h.isVictoryPiece = true);
                        this.endGame();
                        return;
                    }
                }

                // Continue turn
                if (this.huntersMoved.size === this.hunters.length) {
                    this.endTigerTurn();
                } else {
                    logStatus(`${5 - this.huntersMoved.size} Hunters remaining.`);
                }
            }

            endGame() {
                console.log("=== GAME OVER ===");
                this.canvas.style.cursor = 'default';
                this.draw();
            }

            draw() {
                console.log("Drawing board...");
                
                // Clear
                this.ctx.fillStyle = '#ecf0f1';
                this.ctx.fillRect(0, 0, 800, 800);
                
                // Draw zones
                this.ctx.strokeStyle = '#f39c12';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(this.center.x, this.center.y, CLEARING_RADIUS, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.strokeStyle = '#3498db';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.center.x, this.center.y, CLEARING_RADIUS + BORDERLANDS_WIDTH, 0, Math.PI * 2);
                this.ctx.stroke();

                // Victory triangle
                if (this.winningHunters && this.winner === 'HUNTERS') {
                    const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.5;
                    this.ctx.fillStyle = `rgba(46, 204, 113, ${pulse})`;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.winningHunters[0].pos.x, this.winningHunters[0].pos.y);
                    this.winningHunters.forEach(h => this.ctx.lineTo(h.pos.x, h.pos.y));
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = `rgba(39, 174, 96, ${pulse + 0.3})`;
                    this.ctx.lineWidth = 4;
                    this.ctx.stroke();
                }

                // Range indicator for selected piece
                if (this.selectedPiece) {
                    this.ctx.strokeStyle = 'rgba(241, 196, 15, 0.6)';
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.arc(this.selectedPiece.pos.x, this.selectedPiece.pos.y, HAND_SPAN, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    this.ctx.fillStyle = '#f39c12';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.fillText(`Max range: ${HAND_SPAN}px`, 10, 30);
                }
                
                // Draw pieces
                this.tiger.draw(this.ctx);
                this.hunters.forEach(h => h.draw(this.ctx));
                
                // Turn indicator
                const indicator = document.getElementById('turn-indicator');
                if (this.winner) {
                    indicator.textContent = `${this.winner} WINS!`;
                    indicator.style.color = '#e74c3c';
                } else {
                    indicator.textContent = `${this.turn}'s Turn`;
                    indicator.style.color = this.turn === 'TIGER' ? '#e74c3c' : '#27ae60';
                }
            }
        }

        // ========== START ==========
        console.log("=== PAGE LOADING ===");
        let game;

        window.addEventListener('load', () => {
            console.log("Window load event fired");
            try {
                game = new Game();
                console.log("Game instance created successfully");
            } catch (error) {
                console.error("Failed to create game:", error);
                logStatus(`CRITICAL ERROR: ${error.message}`, "error");
            }
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            console.log("Reset button clicked");
            if (game) {
                game.reset();
                logStatus("Game reset!");
            }
        });
    </script>
</body>
</html>
